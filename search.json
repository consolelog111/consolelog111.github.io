[{"title":"2022の回顧 × 2023の26問","url":"/2022/12/26/2022%E3%81%AE%E5%9B%9E%E9%A1%A7-%C3%97-2023%E3%81%AE26%E5%95%8F/","content":"\n用一下好久没来过的博客吧XD \n模板来自 https://shimo.im/docs/ppcRPkXxxWWDxWJX/read\n\n\n2022熱身編\n你是誰？ 你是懷著甚麼心態做這份問卷的？\n\n圣诞节的第二天！现在的我，刚刚吃完剩下的半块草莓蛋糕，外放爵士乐，申请了23fall的第一所大学，带着完成了一件大事的放松感来填写这个年终答卷。ps.来自一个还没阳的人\n\n\n2022年，有特別喜歡的 / 有記憶的曲子 / 歌手嗎？爬墙了呢！tour了档和噜妹，从🌸粉爬到团偏现在隐隐约约有回来的迹象。另外，变成次粉了！并在积极熟悉捕梦网中————现在从爱主打转为爱专辑整体了，喜欢有intro的专辑\n\n\n2022年，有特別喜歡的 / 有記憶的電影嗎？\n\n今年好像没怎么看电影。能想到的电影，也记不起来到底是不是今年看的。确认是今年的记忆中的电影，那只有跟波波看的《阿特拉斯耸耸肩》了\n\n\n2022年，有特別喜歡的 / 有記憶的書嗎？\n\n倒是看了不少书（但是看完的并不多呢最爱的一本是马尔克斯的《梦中的欢快葬礼及十二个异乡人的故事》，翻来覆去看了好几遍。马尔克斯的每一本书我都很喜欢，读起来很有意思。\n\n\n\n2022年，在興趣、食物…等等喜好方面有改變嗎？如有，是甚麼呢？\n\n好像也是有？自从跟波波在一起之后，口味淡了不少，爱上水煮菜了。\n\n\n\n2022 自己回顧編\n你對自己在2022年的學業 / 工作滿意嗎？\n\n其实不算太满意，今年是没什么进步的一年，但是过的很舒服，可能这就是代价吧（😀\n\n\n你對自己在2022年的戀愛狀況滿意嗎？\n其实不算太满意，今年是没什么进步的一年，但是过的很舒服，可能这就是代价吧（😀（同上（不是好像很熟，又感觉很疏远，有机会多聊一下吧\n你對自己在2022年的身體狀況滿意嗎？\n\n\n今年问题有些严重哦！长了满脸的痘痘，现在还没有消下去不过现在还没有感染新冠，嗯，说不定还不错呢\n\n\n 2022年特別值得感謝的人 / 新認識的、特別值得記下的人是？\n\n没怎么认识新朋友呢。那还是感谢波波吧！\n\n\n  2022年特別值得紀念的事情是？\n\n出去玩！在疫情的夹缝里玩了两趟。出差去了兰州，面食者的天堂！跟着项目组去了青海，淡季包场了整个天空之镜。中秋和波波一起去了烟台龙口，很美的海边，很美味的海鲜。如果能再出去玩一趟就好啦！想去泡温泉！\n\n\n 2022年特別後悔的事情是？现在最最最后悔的事就是犯懒，逃避了雅思转考了PTE，试一试说不定能考出来呢。那样就能多申好多好学校了，哭哭\n\n\n 回想起2022年新年的時候，有許下過甚麼願望 / 計劃嗎？如有，是甚麼呢？当时还在准备跳槽呢，谁想的到现在直接跳到北欧了呢\n\n\n 回顧快將過去（/ 已經過去）的2022年，有達成了以上那些計劃嗎？達成了哪些？\n工作上的，貌似都没有达成，我的工作和职业规划依然一塌糊涂英语能力提升了，还开始了23fall的申请没有交到什么朋友，很难过啦，不过还可以努力和家里的联络也多起来了，很好。被波波影响挺多的，现在逐渐能控制自己的情绪好转了。\n  2022年尚未達到、想在新的一年再接再厲的目標是？\n工作！希望能够成功跳槽学习！如果录取不到的话，需要攒钱+英语学习，争取把雅思考个好分数出来\n\n\n 總結2022年，你覺得你自己（對任何事情）的心態有改變嗎？改变挺大的。尤其是11月份，因为疫情封控的原因，不得不推着自己往前赶，一个月完成了信用卡办理、开证明、找教务处盖章、考出英语、办护照等一系列麻烦的事情，现在想想还是觉得自己很棒！\n\n\n你覺得自己在2022年的表現如何？\n\n总的来说，很棒！\n\n2022年，對你來說是怎樣的一年？/ 在你的人生中扮演著甚麼角色呢？记得年初当时在日记里写，感觉今年会是很重要的一年，希望自己能好好抓住机会。有没有好好抓住机会呢，我也不知道。未来回想今年会怎么评价，我也不知道。但无论如何，我希望这是一切的转折点，无论转向何方。\n\n\n2023 展望編\n期待新年的到來嗎？2023在你的人生中將扮演著怎樣的角色呢？\n\n十分期待！可以说今年的申请结果直接决定了我的未来XD\n\n\n 在學業或是工作方面，2023年有什麼重要的行程跟規劃呢？\n\n明年将会是改变的一年，无论是工作还是学业。申请完瑞典的学校，就着手准备跳槽的事情了，希望两边都可以成功。\n\n\n 2023年有什麼特別的旅遊計畫嗎？\n\n其实有打算去看演唱会的XD但是大概率要出国，所以还是浅浅的期待一下旅游打算去广州，去南边，去吃特色小吃。\n\n\n 在戀愛方面，新的一年對自己有什麼期許嗎？\n\n打算找个机会和波波敞开聊聊，两个无所谓的人，有一个更在乎的话，也可能会不快乐。希望自己能更坦率一点，不要委屈自己！\n\n\n 2023年還有甚麼想達到的事？ / 有甚麼願望？ / 有甚麼目標？想要交朋友！\n\n\n 請寫下2023年預定要看的書 + 買的CD + 看的電影 + 買的東西。书：要把kindle的存货看完哦CD：这很难说，因为我全都要.jpg 应该会买炽和次的电影：存货看一看啦买东西：斯普拉顿！3！\n\n\n2023年，你想成为一个怎样的人呢？\n我希望我可以更勇敢的对待世界，更真诚的对待自己。我想要自己醒着的时间能更长久一些。\n 在這裡，請對2023年12月31日的自己說一些話。\n我不知道你现在身在哪里，不过对于我来说也不是那么重要了。人生太过偶然了，祝愿那时的你，能和现在的我一样幸福。\n\n"},{"url":"/2023/05/20/Vue2%E3%80%81Vue3%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"一、vue3新出的一个语法糖相较原写法setup(){}1.可以自动注册子组件2.不需要手动返回模板需要使用的属性和方法3.提供了三个新的API来供我们使用：defineProps、defineEmit和useContext。其中defineProps用来接收父组件传来的值props。defineEmit用来声明触发的事件表。useContext用来获取组件上下文context\n二、生命周期名字大部分需要 + on，功能上类似。setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地去定义beforeCreate和created两个生命周期\n三、Vue3 支持了多根节点组件\n四、Vue2 的响应式原理基础是 Object.defineProperty，有以下缺点不能监听数组的变化必须遍历对象的每个属性必须深层遍历嵌套的对象不能监听数组的变化Vue3 响应式原理基础是Proxy，相较于 Object.defineProperty 提供语言全范围的响应能力，消除了局限性，但在兼容性上放弃了IE11及以下。\n五、新的组件1、Fragment在Vue2中: 组件必须有一个根标签在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中好处: 减少标签层级, 减小内存占用2、TeleportTeleport 是一种能够将我们的组件html结构移动到指定位置的技术。3、Suspense等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n六、性能优化1、编译阶段优化，使得项目运行时候的内存占用少。2、Vue3移除了一些不常用的API，引入tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了。\n七、开发风格变化Vue2中，代码是Options API风格的，也就是通过填充（option）data、methods、computed等属性来完成一个Vue组件，代码分开实现Vue3中，舍弃了Options API，开始使用Composition API。更接近原生JS，组件根据逻辑功能来组织，一个功能所定义的所有代码会放在一起，更加的高内聚，低耦合，更适合代码的复用\n其他变化1、data选项应始终被声明为一个函数2、过渡类名的更改3、移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes4、移除v-on.native修饰符5、移除过滤器（filter）\n"},{"url":"/2023/05/20/Vue3%E7%9A%84%E4%BC%98%E5%8C%96/","content":"https://www.jianshu.com/p/ab6741d8ee1chttps://blog.csdn.net/weixin_44337386/article/details/126240442\n一、vue3新出的一个语法糖相较原写法setup(){}1.可以自动注册子组件2.不需要手动返回模板需要使用的属性和方法3.提供了三个新的API来供我们使用：defineProps、defineEmit和useContext。其中defineProps用来接收父组件传来的值props。defineEmit用来声明触发的事件表。useContext用来获取组件上下文context\n二、生命周期名字大部分需要 + on，功能上类似。setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地去定义beforeCreate和created两个生命周期\n三、Vue3 支持了多根节点组件\n四、Vue2 的响应式原理基础是 Object.defineProperty，有以下缺点不能监听数组的变化必须遍历对象的每个属性必须深层遍历嵌套的对象不能监听数组的变化Vue3 响应式原理基础是Proxy，相较于 Object.defineProperty 提供语言全范围的响应能力，消除了局限性，但在兼容性上放弃了IE11及以下。\n五、新的组件1、Fragment在Vue2中: 组件必须有一个根标签在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中好处: 减少标签层级, 减小内存占用2、TeleportTeleport 是一种能够将我们的组件html结构移动到指定位置的技术。3、Suspense等待异步组件时渲染一些额外内容，让应用有更好的用户体验\n六、性能优化\n其他变化1、data选项应始终被声明为一个函数2、过渡类名的更改3、移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes4、移除v-on.native修饰符5、移除过滤器（filter）\n编译阶优化段–更快化了运行时候的内存占用\n源码体积有优化–更小打包的整体体积变小。Vue3移除一些不常用的API，引入tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了。简单来说，treeshaking就是找出使用的代码。\n开发更友好：1、开发风格变化，更接近原生JS，带给开发者更多的灵活性Vue2中，代码是Options API风格的，也就是通过填充（option）data、methods、computed等属性来完成一个Vue组件。这种风格始得Vue容易上手，但是Options API不够灵活，组件间很难优雅的公用代码在Vue3中，舍弃了Options API，开始使用Composition API。组件根据逻辑功能来组织的，一个功能所定义的所有代码会放在一起（更加的高内聚，低耦合）。\n&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;    Count: &#123;&#123; count &#125;&#125;  &lt;/button&gt;&lt;/template&gt; &lt;script&gt;// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数import &#123; ref, computed, onMounted &#125; from &#x27;vue&#x27; export default &#123;  setup() &#123;// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数    const count = ref(0) // Vue2中需要在methods option中声明的函数，现在直接声明    function increment() &#123;      count.value++    &#125; // 对应于Vue2中的mounted声明周期    onMounted(() =&gt; console.log(&#x27;component mounted!&#x27;))     return &#123;      count,      increment    &#125;  &#125;&#125;&lt;/script&gt;\n\n2、响应式实现优化改用proxy api做数据劫持Vue.js 2.x 内部是通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter 来实现响应式的。这个 API 有一些缺陷，它必须预先知道要拦截的 key 是什么，因此，vue2中对数组和对象操作时，对于对象属性的新增删除、数组的针对下标赋值、长度修改等操作，需要额外使用this.$set进行响应式的触发而vue3中，Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性，包括新增属性和删除属性，并且Proxy可以监听数组的变化，不需要进行额外操作来实现视图的更新。\n"},{"url":"/2023/05/20/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE+%E8%B0%83%E7%A0%94%E8%BF%87%E7%A8%8B/","content":"初始环境：Python 3.6；已配置python环境，已安装PyCharm；cuda驱动nvcuda.dll版本11.3.55conda虚拟环境：Python 3.8需安装：\n\nAnaconda conda 4.10.1\nPyTorch torch.version 1.12.1\n\n❗ 但是torch.cuda.is_available()为Flase，运行会报warning User provided device_type of ‘cuda’, but CUDA is not available可能是版本不对， 但是不影响使用安装教程：https://blog.csdn.net/Bluebro/article/details/127161165https://blog.csdn.net/qq_42257666/article/details/121383450（之后的PyTorch以及模型包都在conda虚拟环境下安装）\n\nJupyter \n\n安装教程：https://blog.csdn.net/fakejvruo/article/details/124409158使用教程：https://blog.csdn.net/qq_25953411/article/details/128089673\n\nspaCy及模型安装：\n\n安装教程⭐：https://blog.csdn.net/weixin_44007213/article/details/113155998示例代码：\nimport spacy# s = &quot;患者10月前无明显诱因出现右下腹包块，无发热寒战，无乏力纳差，就诊于某某医院，确诊弥漫大B细胞淋巴瘤10月。&quot;s = &quot;小米董事长叶凡决定投资华为。在2002年，他还创作了&lt;遮天&gt;。&quot;nlp = spacy.load(&quot;zh_core_web_sm&quot;)doc = nlp(s)# 1. 分句 (sentencizer)for i in doc.sents:    print(f&quot;\\n 分句：&#123;i&#125;&quot;)    # 2. 分词 (Tokenization)print(f&quot;\\n 分词：&quot;)print([w.text for w in doc])# 3. 词性标注 (Part-of-speech tagging)print(f&quot;\\n 词性标注：&quot;)print([(w.text, w.tag_) for w in doc])  # 细粒度print([(w.text, w.pos_) for w in doc])  # 粗粒度# 4. 识别停用词 (Stop words)print(f&quot;\\n 识别停用词：&quot;)print([(w.text, w.is_stop) for w in doc])# 5. 命名实体识别 (Named Entity Recognization)print(f&quot;\\n 命名实体识别：&quot;)print([(e.text, e.label_) for e in doc.ents])# 6. 依存分析 (Dependency Parsing)print(f&quot;\\n 依存分析：&quot;)print([(w.text, w.dep_) for w in doc])# 下面的只有英文模型有# 词性还原 (Lemmatization)# 提取名词短语 (Noun Chunks)# 指代消解 (Coreference Resolution)\n\n\njieba分词\npkuseg 医疗领域分词\n\n安装教程：https://blog.csdn.net/TFATS/article/details/108851344\n"},{"title":"Vue前端模板整理","url":"/2021/11/28/Vue%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%95%B4%E7%90%86/","content":"模块划分\n目录结构├── build                      // 构建相关  里面是一些脚本文件，用来构建的时候调用，完成相应操作，这些脚本调用的是nodejs提供的api。nodejs是一个js语言的运行环境，类比一下就是jvm相对于java的关系。dist  打包生成的东西mock Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发更加独立自主，不会被服务端的开发所阻塞。node_modules npm install 安装的本项目所需的依赖包 plop-templates 一个自动生成模板代码的小工具├── public                     // 公共文件│   ├── favicon.ico            // favicon图标│   └── index.html             // html模板-----------这个！和底下的俩tinymce  富文本编辑器？├── src                        // 源代码│   ├── api                    // 所有请求│   ├── assets                 // 主题 字体等静态资源│   ├── components             // 全局公用组件│   ├── directive              // 全局指令  自定义的vue指令│   ├── filtres                // 全局 filter│   ├── icons                  // 项目所有 svg icons│   ├── lang                   // 国际化 language│   ├── layout                 // 布局│   ├── router                 // 路由│   ├── store                  // 全局 store管理│   ├── styles                 // 全局样式│   ├── utils                  // 全局公用方法│   ├── vendor                 // 公用vendor  第三方模板│   ├── views                   // view│   ├── App.vue                // 入口页面│   ├── main.js                // 入口 加载组件 初始化等新建一个vue项目，一般一个初步的Vue项目创建好之后都会有这三个文件：index.html 、main.js 、App.js;Vue是单页面形式开发，而这个index.html文件在其中起着特别重要的作用。所有组件（后缀名为.vue都被视为组件）都会通过此文件进行渲染加载。main.js : 这个文件，在我看来，它相当于一个C/Java中的入口函数。控制着初次启动Vue项目要加载的组件。下面是main.js的代码截图，我会对每行代码进行逐一分析import  A   from  ‘B’   这类语句相当于引入B（这一般是路径）然后给它起个名字叫做A；Vue.user(C)这个意思是 全局方法定义 C。也就是说，定义以后，你可以在这个Vue项目的任意地方使用该组件（当然，你不能乱写）。el: &#x27;#app&#x27;和html文件里的app相对应，模板将会替换挂载的元素。-----------------------------------？？？App.vue：组件。额，暂且，你可以把它认为是一个根组件。export中的name属性，相当于给这个组件定义一个名字。便于识别和使用。created: 这是一个生命周期函数，因为App这个组件中并没有任何信息。他只是作为根组件来使用。所以，我们要在进入这个组件的时候跳转到一个初始化界面--login。（个人感觉App没啥用，index.html和main.js完全可以实现这些功能）。   下面，我们来总结一下，vue项目的启动，在表层可视为main.js--&gt;App.vue（组件）--&gt;index.html│   └── permission.js          // 权限管理│   └── settings.js            // 系统配置├── .editorconfig              // 编码格式├── .env.development           // 开发环境配置├── .env.production            // 生产环境配置├── .env.staging               // 测试环境配置├── .eslintignore              // 忽略语法检查├── .eslintrc.js               // eslint 配置项├── .gitignore                 // git 忽略项├── babel.config.js            // babel.config.js  babel  简单来说把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。├── package.json               // package.json└── vue.config.js              // vue.config.js\n状态共享Vuex我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏：多个视图依赖于同一状态。来自不同视图的行为需要变更同一状态。对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！\nstatemutationsactions👆modulesgetters\n\nstate 存放状态，我们想要共享的东西、值mutations state成员操作，针对stare的操作定义，是操作state数据的方法的集合，比如对该数据的修改、增加、删除等等。\n\ngetters 加工\n可以对state中的成员加工后传递给外界Getters中的方法有两个默认参数state 当前VueX对象中的状态对象getters 当前getters对象，用于将getters下的其他getter拿来用\nstate成员给外界\nactions 异步操作由于直接在mutation方法中进行异步操作，将会引起数据失效（https://segmentfault.com/q/1010000014733271）。所以提供了Actions来专门进行异步操作，最终提交mutation方法。Actions中的方法有两个默认参数context 上下文(相当于箭头函数中的this)对象payload 挂载参数\nmodules 模块化状态管理\n\n我们所要做到的是：不同的权限对应着不同的路由，同时侧边栏也需根据不同的权限，异步生成。这里先简单说一下，我实现登录和权限验证的思路。\n\n登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。\n权限验证：通过token获取用户对应的 role，动态根据用户的 role 算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。\n\n上述所有的数据和操作都是通过vuex全局管理控制的。(补充说明：刷新页面后 vuex的内容也会丢失，所以需要重复上述的那些操作)接下来，我们一起手摸手一步一步实现这个系统。\n登录流程\n登录验证拿token当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态\n\n登录页面（login.vue），点击登录按钮\n handleLogin() &#123;      this.$refs.loginForm.validate(valid =&gt; &#123;        if (valid) &#123;          this.loading = true          this.$store            .dispatch(&#x27;user/login&#x27;, this.loginForm)  //提交表单            .then(() =&gt; &#123;              this.$router.push(&#123;                path: this.redirect || &#x27;/&#x27;,    //跳转首页                query: this.otherQuery              &#125;)              this.loading = false            &#125;)            .catch(() =&gt; &#123;              this.loading = false            &#125;)        &#125; else &#123;          console.log(&#x27;error submit!!&#x27;)          return false        &#125;      &#125;)    &#125;\n表单提交，走登录方法（/store/user.js）\n\n登录成功后，服务端会返回一个 token（该token的是一个能唯一标示用户身份的一个key），之后我们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不用再去登录页面重新登录了。\n\n\n  Login(&#123; commit &#125;, userInfo) &#123;      const username = userInfo.username.trim()      const password = userInfo.rsaPass      const code = userInfo.code      const uuid = userInfo.uuid      return new Promise((resolve, reject) =&gt; &#123;        login(username, password, code, uuid).then(res =&gt; &#123;   //后端返回token          localStorage.setItem(&#x27;id&#x27;, res.user_id)          setToken(res.access_token)    //调用@/utils/auth中方法存储token          setRefreshToken(res.refresh_token)    // 刷新token          commit(&#x27;SET_TOKEN&#x27;, res.access_token)          resolve()        &#125;).catch(error =&gt; &#123;          reject(error)        &#125;)      &#125;)    &#125;\n\n存储token(@/utils/auth)\n\nexport function getToken() &#123;  return Cookies.get(TokenKey)&#125;export function setToken(token) &#123;  return Cookies.set(TokenKey, token)&#125;\n拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）\n获取用户信息用户登录成功之后，我们会在全局钩子router.beforeEach中拦截路由，判断是否已获得token，在获得token之后我们就要去获取用户的基本信息了（permission.js）\nif (hasToken) &#123;     //判断是否获取到token    if (to.path === &#x27;/login&#x27;) &#123;      // if is logged in, redirect to the home page      next(&#123; path: &#x27;/&#x27; &#125;)      NProgress.done() // hack: https://github.com/PanJiaChen/vue-element-admin/pull/2939    &#125; else &#123;      if (store.getters.roles.length === 0) &#123;        // 判断当前用户是否已拉取完user_info信息        store.dispatch(&#x27;GetInfo&#x27;).then(res =&gt; &#123;          // 拉取user_info          const roles = res.roles          store.dispatch(&#x27;GenerateRoutes&#x27;, &#123; roles &#125;).then(accessRoutes =&gt; &#123;            // 测试 默认静态页面            // store.dispatch(&#x27;permission/generateRoutes&#x27;, &#123; roles &#125;).then(accessRoutes =&gt; &#123;            // 根据roles权限生成可访问的路由表            router.addRoutes(accessRoutes) // 动态添加可访问路由表            // console.log(accessRoutes)            next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成            // console.log(&#x27;==============init menu finish=========&#x27;)          &#125;)        &#125;)\n就如前面所说的，我只在本地存储了一个用户的token，并没有存储别的用户信息（如用户权限，用户名，用户头像等）。有些人会问为什么不把一些其它的用户信息也存一下？主要出于如下的考虑：假设我把用户权限和用户名也存在了本地，但我这时候用另一台电脑登录修改了自己的用户名，之后再用这台存有之前用户信息的电脑登录，它默认会去读取本地 cookie 中的名字，并不会去拉去新的用户信息。所以现在的策略是：页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token,就会把这个 token 返给后端去拉取user_info，保证用户信息是最新的。 当然如果是做了单点登录得功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。而且从代码层面我建议还是把 login和get_user_info两件事分开比较好，在这个后端全面微服务的年代，后端同学也想写优雅的代码\n前端权限\n前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每一个后台的请求不管是 get 还是 post 都会让前端在请求 header里面携带用户的 token，后端会根据该 token 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状态码，做出相对应的操作。\n权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 token 获取用户的 role（getinfo）动态根据用户的 role 算出其对应有权限的路由（getRouters）再通过router.addRoutes动态挂载路由。这些控制都只是页面级的\n具体实现\n创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。\n当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。\n调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。\n使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。\n\n@/router/index.js\n//所有权限通用路由表//如首页和登录页和一些不用权限的公用页面（@/permission.js）\nrouter.beforeEach(async(to, from, next) =&gt; &#123;  // start progress bar  NProgress.start()  // set page title  document.title = getPageTitle(to.meta.title)  // determine whether the user has logged in  const hasToken = getToken()  if (hasToken) &#123;    if (to.path === &#x27;/login&#x27;) &#123;      // if is logged in, redirect to the home page      next(&#123; path: &#x27;/&#x27; &#125;)      NProgress.done()     &#125; else &#123;      if (store.getters.roles.length === 0) &#123;        // 判断当前用户是否已拉取完user_info信息        store.dispatch(&#x27;GetInfo&#x27;).then(res =&gt; &#123;          // 拉取user_info          const roles = res.roles          store.dispatch(&#x27;GenerateRoutes&#x27;, &#123; roles &#125;).then(accessRoutes =&gt; &#123;                                                                         // 根据roles权限生成可访问的路由表            router.addRoutes(accessRoutes)                   // 动态添加可访问路由表            next(&#123; ...to, replace: true &#125;) // hack方法 确保addRoutes已完成            // console.log(&#x27;==============init menu finish=========&#x27;)          &#125;)        &#125;)          .catch(err =&gt; &#123;            store.dispatch(&#x27;FedLogOut&#x27;).then(() =&gt; &#123;              Message.error(err)              next(&#123; path: &#x27;/&#x27; &#125;)            &#125;)          &#125;)      &#125; else &#123;        next()      &#125;    &#125;  &#125; else &#123;    /* has no token*/    console.log(to.path)    if (whiteList.indexOf(to.path) !== -1) &#123;// 免登录白名单      next()    &#125; else &#123;      next(`/login`)      NProgress.done()    &#125;  &#125;&#125;)\n@/store/modules/permission.js通过用户的权限和之前在router.js里面asyncRouterMap的每一个页面所需要的权限做匹配，最后返回一个该用户能够访问路由有哪些。\nconst permission = &#123;  state: &#123;    routes: [],    addRoutes: []  &#125;,  mutations: &#123;    SET_ROUTES: (state, routes) =&gt; &#123;      state.addRoutes = routes      state.routes = constantRoutes.concat(routes)    &#125;  &#125;,  actions: &#123;    // 生成路由    GenerateRoutes(&#123; commit &#125;) &#123;      return new Promise(resolve =&gt; &#123;        // 向后端请求路由数据        getRouters().then(res =&gt; &#123;          const accessedRoutes = filterAsyncRouter(res.data)          accessedRoutes.push(&#123; path: &#x27;*&#x27;, redirect: &#x27;/404&#x27;, hidden: true &#125;)          commit(&#x27;SET_ROUTES&#x27;, accessedRoutes)          resolve(accessedRoutes)        &#125;)      &#125;)    &#125;  &#125;&#125;// 遍历后台传来的路由字符串，转换为组件对象function filterAsyncRouter(asyncRouterMap) &#123;  return asyncRouterMap.filter(route =&gt; &#123;    if (route.path === &#x27;/&#x27;) &#123;      route.redirect = &#x27;home&#x27;    &#125;    if (route.component) &#123;      // Layout组件特殊处理      if (route.component === &#x27;Layout&#x27;) &#123;        route.component = Layout      &#125; else &#123;        route.component = loadView(route.component)      &#125;    &#125;    if (route.children != null &amp;&amp; route.children &amp;&amp; route.children.length) &#123;      route.children = filterAsyncRouter(route.children)    &#125;    return true  &#125;)&#125;export const loadView = (view) =&gt; &#123; // 路由懒加载  return (resolve) =&gt; require([`@/views/$&#123;view&#125;`], resolve)&#125;export default permission\n\n\n路由流程\nVue Router\n\n单页应用/多页应用多页：每一次页面跳转的时候，后台服务器都会给返回一个新的html文档，这种类型的网站也就是多页网站，也叫做多页应用。ttp://xxx/page2.html单页：第一次进入页面的时候会请求一个html文件，刷新清除一下。切换到其他组件，此时路径也相应变化，但是并没有新的html文件请求，页面内容也变化了。原理是：JS会感知到url的变化，通过这一点，可以用js动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求html文件了。\n\n多页面的时候，写页面之间的跳转就是a标签，但是Vue做的都是单页应用，标签是不起作用的，你必须使用vue-router来进行管理。路由模块的本质 就是建立起url和页面之间的映射关系。\n资料什么是nodejshttps://www.jianshu.com/p/6062ee5354be\nnpm 是干什么的https://zhuanlan.zhihu.com/p/24357770\nvue项目启动过程https://blog.csdn.net/cxf8881/article/details/80620545\nvuex官方文档https://vuex.vuejs.org/zh/\nvuex的使用https://www.jianshu.com/p/2e5973fe1223\nvue Router官方文档https://router.vuejs.org/zh/\nvue router入门https://www.jianshu.com/p/4c5c99abb864\n"}]